#unity优化
在使用相同材质球的情况下，Unity会在运行时对于正在视野中的符合条件的动态对象在一个Draw call内绘制，所以会降低Draw Calls的数量。

如果两种相同材质仅在纹理上不同，可将这些纹理组合成单个大纹理。此过程通常称为纹理镶嵌（Texture atlasing）

 阴影也可以接受批处理，即使它的阴影投射物具有不同的材质，只要阴影 pass 所需材质中的值相同即可。

## Meshes

### 批处理只适用于包含不超过900个顶点属性和不超过300个顶点的网格

### 要进行动态批处理的对象的Scale必须相同

### 材质相同

### 带有光照贴图的游戏对象具有其他渲染器参数：光照贴图索引和光照贴图偏移/缩放。通常，动态光照贴图的游戏对象应指向要批处理的完全相同的光照贴图位置。

### 多 pass 着色器会中断批处理。

### 因为动态批处理的工作原理是将所有游戏对象顶点转换到 CPU 上的世界空间，所以仅在该工作小于进行绘制调用（Draw Call）的情况下，才有优势。绘制调用的资源需求取决于许多因素，主要是使用的图形 API。例如，对于游戏主机或诸如 Apple Metal 之类的现代 API，绘制调用的开销通常低得多，通常动态批处理根本没有优势。

## Particle Systems, Line Renderers, Trail Renderers

### 动态批处理在用于具有 Unity 动态生成的几何体的组件时，其工作方式与用于网格时不同。

### 对于每个兼容的渲染器类型，Unity 将所有可批处理的内容构建为 1 个大型顶点缓冲区。

### 渲染器设置材质状态以用于批处理。

### Unity 将顶点缓冲区绑定到图形设备。

### 对于批处理中的每个渲染器，Unity 将偏移更新到顶点缓冲区中，然后提交新的绘制调用。

### 在衡量图形设备调用的成本时，渲染组件时的最慢部分是材质状态的设置（Material state）。相比之下，将不同偏移处的绘制调用提交到共享顶点缓冲区中的速度非常快。

### 这种方法与 Unity 在使用静态批处理时提交绘制调用的方式非常相似。

## Tips

### 当前，仅对网格渲染器、轨迹渲染器、线渲染器、粒子系统和精灵渲染器进行批处理。这意味着不会对蒙皮网格、布料和其他类型的渲染组件进行批处理。

### 渲染器仅与其他相同类型的渲染器一起接受批处理。

### 半透明着色器通常要求游戏对象按照从后到前的顺序进行渲染，从而实现透明性。Unity 首先按此顺序对游戏对象排序，然后尝试对它们进行批处理，但是因为必须严格满足顺序，所以这通常意味着可以实现比不透明游戏对象更少的批处理。

### 合并网格：手动组合彼此接近的游戏对象可以是绘制调用批处理的极好替代方法。例如，一个带有大量抽屉的静态橱柜通常只需在 3D 建模应用程序中或者使用 Mesh.CombineMeshes 来组合成一个网格。

![%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86%202c0e61d4117a45159ae40ae55974d561/Untitled.png](动态批处理流程图.png)

### 官方文档：

[绘制调用批处理 - Unity 手册](http://docs.unity3d.com/cn/current/Manual/DrawCallBatching.html)