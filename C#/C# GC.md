#CSharp
## 垃圾回收算法
- **引用计数法**
堆上的每个对象都维护着一个内存字段来统计程序中有多少地方正在引用该对象。
对象计数为0时就可以从内存删除了。
引用计数系统最大的问题是处理不好循环引用。

- **引用跟踪算法**
CLR所使用的算法。
引用跟踪算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象。
我们将所有引用类型的变量称为==根==。
	- CLR开始GC时，先暂停进程中的所有线程。这样**可防止线程在CLR检查期间访问对象并更改状态**。
	- 然后CLR进入GC的==标记阶段==。在这个阶段，CLR遍历堆中所有对象，将同步块索引字段中的一位设为0。这表明所有对象都应删除。（先把它们丢进垃圾桶）
	- 然后CLR检查所有活动根，查看它们引用了哪些对象。如果一个根包含null，CLR忽略这个根并继续检查下个根。任何根如果引用了堆上的对象，CLR都会标记那个对象，也就是将该对象的同步块索引中的位设为1。（再给它们复原，没复原的就回收）一个对象被标记后，CLR会检查那个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。这就避免了循环引用而产生的死循环。
	-  已标记的对象不能被垃圾回收，因为至少有一个根在引用它，我们说这种对象是可达的（reachable）。
	- 未标记的对象是不可达的（unreachable）。
	- CLR知道哪些对象可以幸存，哪些可以删除后，就进入GC的压缩阶段。**CLR对堆中已标记的对象进行压缩，使它们占用连续的内存空间。**（提升访问这些对象的性能。扩大可用空间。解决空间碎片化问题。）作为压缩的一部分，CLR还要从每个根减去所引用的对象在内存中偏移的字节数。（因为“搬家”了）

### 提升性能
CLR的GC是==基于代的垃圾回收器==。它对代码做出以下几点假设。
-   **对象越新，生存期越短。**
-   **对象越老，生存期越长。**
-   **回收堆的一部分，速度快于回收整个堆。**

托管堆在初始化时不包含对象。添加到堆的对象称为==第0代对象==。
CLR初始化时为第0代对象选择一个==预算容量==（以KB为单位）。**如果分配一个新对象造成第0代超过预算，就必须启动一次垃圾回收**。
在垃圾回收中存活的对象成为==第1代对象==。经过一次垃圾回收后，第0代就已经不包含任何对象了。
新的对象会分配到第0代中。
当再次开始垃圾回收时，垃圾回收器会检查第1代占用多少内存，如果少于预算，垃圾回收器只检查第0代的对象。由于越新的对象活得越短，因此第0代包含更多垃圾的可能性很大，能回收更多内存。由于忽略了第1代的对象，所以加快了垃圾回收速度，能在更短的时间内构造好可达对象图。
当然老对象也可能引用新对象。为了确保对老对象的已更新字段进行检查，垃圾回收器利用了JIT编译器内部的一个机制。这个机制在对象的引用字段发生改变时，会设置一个对应的位标志。只有字段变化的老对象才需检查是否引用了第0代中的任何新对象。
如果再次进行垃圾回收，发现第1代也超预算，会对第1代进行回收，幸存的进入第2代，第0代幸存的进入第1代。
**托管堆只支持三代：第0代，第1代，第2代**。

如果垃圾回收器发现在回收0代后存活下来的对象很少，就可能减少第0代的预算，意味着垃圾回收将更频繁发生，但是垃圾回收做的事也减少了。

如果第0代中的所有对象都是垃圾，垃圾回收甚至不必压缩内存，直接让NextObjPtr指针（即指向托管堆当前分配内存的指针）指回第0代的起始处，回收更快了。

相反如果发现回收了第0代还有很多对象存活，则增大第0代的预算。

如果没有会收到足够的内存，垃圾回收器会执行一次完整回收。如果还是不够则抛出OutOfMemoryException异常。

### 终结的内部工作原理
应用程序创建新对象时，new会从堆中分配内存。如果对象的类型定义了Finalize方法，那么**在该类型的实例构造器被调用前，会将指向该对象的指针放进一个终结列表中**。

回收的对象如果是有在终结列表中的，在回收前需调用它的Finalize方法。如果对象没有Finalize方法则直接回收。如果对象有Finalize方法，并且还没有调用，则对象指针会从终结列表移动到freachable队列里。

freachable队列保证了里面的对象是可达的，不是垃圾。从终结列表移动到freachable队列我们叫复活。

垃圾回收器将复活的对象提升到较老的一代。清空freachable队列，执行每个对象的Finalize方法。

下次对老一代进行垃圾回收时，发现已终结的对象成为真正的垃圾，因为没有根指向它们，freachable也不再指向它们，会直接回收。整个过程中，**可终结对象需要执行两次垃圾回收才能释放内存**。