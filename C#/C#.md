**类型基础**
“RunTime要求每个类型最终都从System.Object类型派生。”

Employee e = new Employee("ConstructorParam1");
new操作符所做的事情：
1.  计算类型及其所有基类型（一直到System.Object）中定义所有实例字段所需字节数。堆上每个对象都需要一些额外成员，包括“类型对象指针”（type object pointer)和“同步块索引”(sync block index)。
2.  调用类型的实例构造器。

**类型转换**
CLR最重要的特性就是类型安全。

#### 隐式转换
对象转换成它的任何基类型，是安全的隐式转换。
当对象转换成它的某个派生类型时，C#要求只能显示转换，因为这种转换可能在运行时失败。
只有在转换安全时才允许隐式转换，不安全意味着转换后可能会丢失精度或数量级。
C#熟悉基元类型，会在编译代码的时候应用特殊规则，支持与类型转换、字面值以及操作符有关的模式。

因此Int32和Int64是不同类型，不存在派生关系，也能隐式转换。
Int32 i = 5;
Int64 l = i;

#### as和is的区别
is判断对象是否为该类型，返回true或false

```C#
Object o = new Object();
Boolean b1 = (o is Object);
Boolean b1 = (o is Object);
```
要做两遍判断。
as直接强转换，如果不能转型返回null。
```C#
Object o = new Object();
Employee e = o as Employee;
```
所以as的速度快很多。

### 引用类型和值类型
-   值类型不能派生，所以不应在值类型中引入任何新的虚方法。
-   将值类型变量赋给另一个值类型变量，会逐字段复制。将引用类型的变量赋给另一个引用类型变量只复制内存地址。
-   未装箱的值类型不在堆上分配，一旦定义了该类型的一个实例的方法不再活动（如超出作用域），为它们分配的存储就会被释放，而不是等垃圾回收。

### 装箱和拆箱
**装箱**：将值类型转换成引用类型要使用装箱。
1.  在托管堆中分配内存。
2.  值类型的字段复制到新分配的内存。
3.  返回对象地址。

**拆箱**：获得已装箱对象地址，将字段包含的值从堆复制到基于栈的值类型实例中。
```C#
Point p; //p为值类型
p.x = p.y = 1;
Object o = p; //装箱
p = (Point) o; //拆箱
```
拆箱的代价比装箱低得多。

### 方法
#### 虚方法
设计类型时尽量减少虚方法数量。
- 首先调用虚方法的速度比调用非虚方法慢。
- 其次JIT编译器不能inline虚方法，进一步影响性能。

#### 事件

TODO

#### 委托
TODO

