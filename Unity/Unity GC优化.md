#unity优化 
## Unity的内存
### Unity的内存起源
Unity实际可看作是一个使用C++开发的游戏引擎，它使用`.net`的脚本模拟机。Unity从**虚拟内存**（Virtual Memory）中给原生（C++）对象和虚拟机分配内存，同样第三方插件的内存分配也是在虚拟内存池中。

- **原生内存**（Native Memory）是虚拟内存的一部分，它用来给所有需要的对象分配内存页面，包括**Mono堆**（`Mono Heap`）。
- **Mono堆**是出于虚拟机的需要而专门分配的本机内存的一部分。它包含了所有由`C#`分配的托管的内存类型，而这些内存的托管对象就是垃圾收集器（GC）。
Unity内部有几个专门的分配器，它们负责管理虚拟内存的短期和长期分配需求。所有的Unity资产（Assets）都是存储在原生内存中的。但这些资产会被轻量的包装成Class，以供逻辑访问和调用。*也就是说如果我们用C#创建了一张Texture，它的大部分原始数据（RawData）存在Native内存中，并且会有很小的一个Class对象进入到虚拟机中，也就是Mono堆中。*

### Reserved
**内存分页**（IOS上大部分为16K/page）是内存管理的最小单位，当Unity需要申请内存的时候，都会以block的方式（若干个页）进行申请。如果某一页在若干次GC（IOS为8次）之后仍然为Empty，它就会被释放，实际的物理内存就会被还回给物理内存。
但是Unity是在虚拟内存中管理内存的，因此虚拟空间的地址并不会返还，所以它变成 **Reserved** 的了。这些Reserved地址空间不能再被Unity重复分配了。
如果虚拟内存地址发生频繁分配和释放会导致**地址空间耗尽**，从而被系统杀掉。
![[Pasted image 20221117003604.png]]
堆内存被GC了，这部分物理地址会空出来
![[Pasted image 20221117003824.png]]
当下一次需要申请堆内存时，Mono堆会先检查当前堆内的空间是否存在连续的空间能容纳这次内存申请，如果不够就会进行一次GC，如果还是不够，就会执行内存扩展操作，向操作系统要更多的内存。（Mono堆申请的物理内存是连续的，并且Mono堆向操作系统申请扩展内存**非常耗时**。所以大部分情况Mono堆尽量保持自己已经申请到的物理内存。）
![[Pasted image 20221117004023.png]]
*空出来又不能被重复利用的内存就成为了内存碎片*

### Profiler Simple View
使用Unity的Profiler进行内存分析
![[Pasted image 20221117004432.png]]
- **Used Total **: 已使用内存。
- **Unity**：所有Unity申请和管理的内存（包含Mono Heap）。
- **Mono**：托管堆内存。
- **GfxDriver**：GPU显存开销，主要由Texture，Vertex buffer，index buffer组成。
*这里的Total Reserved还不是游戏虚拟内存的精确值*
	- 它不包括游戏的二进制可执行文件。
	- GfxDriverbu'bao'kuo