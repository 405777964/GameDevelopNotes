#unity优化 
### 为什么我们需要纹理压缩格式？
- 内存：未经压缩的纹理内存占用过大
- 带宽：尺寸大的纹理导致带宽增多，手机发烫，甚至影响渲染性能。

因此要用一种内存占用既小又能被GPU读取的格式——压缩纹理格式。
纹理压缩对应的算法是以某种形式的**固定速率有损向量量化**将固定大小的像素块编码进固定大小的字节块中。
- **固定速率压缩**：因为GPU需要能够高效的随机访问一个像素，所以对任意像素解码速度不该有太大的变化。
- **向量量化**：将一组大量的点（向量）分成具有近似相同数量的最接近它们的点的组。例如将4X4块像素的颜色以2个基色来表示。
- **压缩比**：通常以比特率或每像素的平均比特数（bits per pixel，bpp）表示，常见的为2~8bpp。

### 为什么我们不适用png、jpg这类常见的压缩格式？
尽管像jpg、png的压缩率很高，但并不适合纹理，主要问题是不支持像素的随机访问，GPU渲染时只使用需要的纹理部分，不可能为了访问某个像素去解码整张纹理。这类格式更适合下载传输以及减少磁盘空间使用。

- ETC （安卓）
- DXT （PC）
- PVRTC（IOS)
- [ASTC](https://huailiang.github.io/blog/2022/astc/)（安卓/IOS）
<p>ASTC是一种基于块的有损压缩算法</p>
#### 特性
- **格式灵活**。ASTC可以压缩1到4个通道之间的数据。并且块大小可变，如4x4、5x4、6x5、10x5等。
- **灵活的比特率**。ASTC在压缩图像时提供了广泛的比特率选择。在0.89bpp到8bpp之间。比特率的选择与颜色格式的选择无关，传统ETC等格式只能是整数的比特率。
- **高级格式支持**。ASTC可以压缩图像在LDR、LDR sRGB、HDR颜色空间，还可以压缩3D体积纹理。
- **改善图像质量**。尽管具有高度的格式灵活性，但在同等比特率下，ASTC在图像质量上的表现优于几乎所有的传统的纹理格式（ETC2、PVRCT和BC等）。
- **格式矩阵全覆盖**。在ASTC尚未出现前，传统的纹理压缩格式支持的颜色格式和比特率的组合相对较少。 ![[Pasted image 20221109002205.png]]

#### 技术要点
- **块压缩**：实时图形的压缩格式需要能够快速有效将随机样本转换为纹理，因此对压缩技术必须做到以下几点：
	- 仅给定一个采样坐标，计算内存中数据的地址。
	- 能够在不解压太多周围数据的前提下解压随机采样。
   所有当代实时压缩格式使用的标准解决方案，是将图像分割成固定大小的像素块，每个块被压缩成固定数量的输入位。这保证Shader以任意顺序快速访问texels，并具有良好的解压成本。
   ASTC中的2D Block footprints范围从4x4到12x12texels，它们都被压缩成**128bit**输出块。通过将128bit除以占用空间中的像素数，便能得到格式比特率（bbp）。
   ![[Pasted image 20221109003132.png]]

- **颜色端点**
	块的颜色数据被编码为**两个颜色端点之间**的梯度。每个texel沿着梯度选择一个位置，然后在解压期间**插值**。
- **颜色分区**
	块内的颜色通常是复杂的，单色渐变通常不能准确捕捉块内的所有颜色。如躺下绿色草地的红球，需要进行两种颜色的划分。
	![[Pasted image 20221109003751.png]]
	ASTC允许单个块最多引用**四个颜色梯度**，称为分区。为了解压，每个texel被分配到一个单独的分区。直接存储每个texel的分区分配将需要大量的解压缩硬件来存储所有块大小。相反，ASTC使用分区索引作为seed值，以算法生成一系列模式。
#### 介绍
[https://zhuanlan.zhihu.com/p/237940807](https://zhuanlan.zhihu.com/p/237940807)
#### 实际总结
[Unity移动平台贴图格式总结](https://zhuanlan.zhihu.com/p/366436672)
#### Unity官方关于各平台推荐默认支持的纹理压缩格式 
[各平台的推荐、默认和支持的纹理压缩格式 - Unity 手册](https://docs.unity3d.com/cn/current/Manual/class-TextureImporterOverride.html)