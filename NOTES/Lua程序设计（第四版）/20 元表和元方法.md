# 元表

- 元表可以修改一个值在未知操作时的行为。如当尝试将两个表相加时，会先检查两者是否有元表，且元表中是否有__add字段，如果有则调用元表中该字段对应的值，即元方法。
- 只能为表设置元表，如果要为其他类型的值设置元表，则必须通过C代码或调试库完成。
- 字符串标准库为所有字符串都设置了同一个元表，而其他类型默认情况都没有元表。

<aside>
💡 setmetatable(set,mt)

</aside>

# 元方法

## 20.1 算术运算相关的元方法

加法   __add
减法   __sub
除法   __div
float除法   __idiv
负数   __unm
取模   __mod
幂运算   __pow
位与   __band
位或   __bor
位异或   __bxor
位取反   __bnot
向左移位   __shl
向右移位   __shr

如果两个表做算术运算，Lua会按照该步骤查找元方法：如果第一个值有元表且元表中存在所需的元方法，Lua就使用这个元方法，`与第二个值无关`。如果第二个值有元表且元表中存在所需的元方法，Lua就使用这个元方法。否则就抛出异常。

## 20.2 关系运算相关的元方法

等于   __eq
小于   __lt
小于等于   __le

### 相等比较有一些限制。如果两个对象的类型不同，那么相等比较操作不会调用任何元方法而直接返回false。

## 20.3 库定义相关的元方法

Lua语言虚拟机会检测一个操作中涉及的值是否有存在对应元方法的元表。

函数setmetatable和getmetatable也用到了元方法，用于保护元表。

__metatable：如果在元表中设置__metatable字段，那么getmetatable会返回这个字段的值，而setmetatable会引发一个错误。

__pairs：当一个对象拥有__pairs元方法时，pairs会调用这个元方法来完成遍历。

## __index元方法

当访问表中不存在的字段时会得到nil。

这些访问会引发解释器查找一个名为__index的元方法。如果没有这个元方法，则返回nil。如果有则由这个元方法来提供最终结果。

```lua
mt.__index = function(_,key)
	return prototype[key]
end
```

__index不一定必须是个函数，也可以是个表。

如果想访问一个表时不调用__index元方法，可以使用函数rawget。

## __newindex元方法

__newindex与__index类似，但前者用于表的更新，后者用于表的查询。

当对一个表中不存在的索引赋值时，解释器就会查找__newindex元方法，如果该元方法存在，那么解释器就调用它而不执行赋值。

如果这个元方法是一个表，解释器就在此表中执行赋值，而不是在原始的表中进行赋值。

如果想访问一个表时不调用__newindex元方法，可以使用函数rawset。