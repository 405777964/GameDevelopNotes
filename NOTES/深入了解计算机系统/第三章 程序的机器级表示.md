## 整数寄存器

![Untitled](NOTES/深入了解计算机系统/第三章%20程序的机器级表示/Untitled.png)

## 条件控制

### 跳转指令

![Untitled](NOTES/深入了解计算机系统/第三章%20程序的机器级表示/Untitled%201.png)

### 两种方式： 条件传送   条件转移

**使用条件传送（conditional move）来实现条件分支**

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条
执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代
处理器上，它可能会非常低效。

一种替代的策略是**使用数据的条件转移**。这种方法计算一个条件操作的两种结果，然
后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但
是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理
器的性能特性。

![Untitled](NOTES/深入了解计算机系统/第三章%20程序的机器级表示/Untitled%202.png)

当机器遇到条件跳转（也称为“分支")时，只
有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻
辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达
到90% 以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，
要求处理器丢掉它为该跳转指令后所有指令己做的工作，然后再开始用从正确位置处起始
的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费
大约15~30 个时钟周期，导致程序性能严重下降。

使用条件传送也不总是会提高代码的效率。例如，如果then-ex pr 或者else-ex pr 的求
值需要大量的计算，那么当相对应的条件不满足时，这些工作就白费了。编译器必须考虑
浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能。

，总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策
略。它们只能用于非常受限制的情况，但是这些情况还是相当常见的，而且与现代处理器
的运行方式更契合。

### switch语句

switch( 开关）语句可以根据一个整数索引值进行多重分支(multiway branching)。

它们不仅提高了C 代码的可读性，
而且通过使用跳转表(jump table) 这种数据结构使得实现更加高效。跳转表是一个数组，
表项t 是一个代码段的地址，这个代码段实现当开关索引值等于1 时程序应该采取的动作。
程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一
组很长的if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数
最无关。GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情
况数量比较多（例如4 个以上），并且值的范围跨度比较小时，就会使用跳转表。

## 3.7 函数调用过程

假设过程P调用过程Q，Q执行后返回到P。 这些动作包括下面一个或多个机制：

- **传递控制**：在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。
- **传递数据**：P必须能向Q提供一个或多个参数，Q必须能够向P返回一个值。
- **分配和释放内存**：开始时Q可能需要为局部变量分配空间，在返回前又必须释放这些存储空间。

### 栈帧

**栈帧（stack frame）**：当函数调用过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为栈帧。

**运行时栈：**

1. 当P调用Q时，会把返回地址压入栈中。
2. Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。
3. 大多数函数调用过程的栈帧都是定长的，在过程开始时就分配好了。除了个别过程需要变长的帧。
4. 通过寄存器，过程P可以传递最多6个整数值（指针和整数），但如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧存储好这些参数。
5. 为了提高空间和事件效率，函数调用过程只分配自己所需的栈帧部分。
6. 许多过程有6个或者更少的参数，那么所有的参数可以通过寄存器传递。
7. 实际上，许多函数甚至不需要栈帧，当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数。

## 3.9 异数的数据结构

### **Struct**

结构的所有组成部分都存放在内存中一段**连续的区域**内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段（如Id) 的**字节偏移**。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

### Union

联合提供了一种方式，能够规避C 语言的类型系统，允许以多种类型来引用一个对象。占的内存大小是多种类型里面最大的那种。

### 数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地
址必须是某个值K( 通常是2 、4 或8) 的倍数。这种对齐限制简化了形成处理器和内存系统
之间接口的硬件设计。

例如：

假设一个处理器总是从内存中取8 个字节，则地址必须为8的倍数。如果我们能保证将所有的double 类型数据的地址对齐成8 的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8 字节内存块中。

Intel 还是建议要对齐数据以提高内存系统的性能。对齐原则是任何K 字节的基本对象的地址必须是K 的倍数。

![Untitled](NOTES/深入了解计算机系统/第三章%20程序的机器级表示/Untitled%203.png)

i和j是int类型，c是char类型，c是1个字节，所以会自动填充三个字节，浪费了内存。

## 3.10 内存溢出

### 内容越界和缓冲区溢出

缓冲区溢出(buffer overflow) ：在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一
种最常见的通过计算机网络攻击系统安全的方法。

### 对抗缓冲区溢出攻击

1 栈随机化

2 栈破坏检测

3 限制可执行代码区域